using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows.Forms;

namespace AuditScaner
{
    public partial class ScannedReport : Form
    {
        public static int identifier = 1;
        private Form currentChildForm;
        private string selectedFileName;
        private string[] lines;
        private readonly string fileLocation = "C:\\VulnerabilityScanner";
        private string[] reg_key = new string[999];
        private string[] value_data = new string[999];
        private string[] reg_item = new string[999];
        private string[] description = new string[999];
        private int index = 0;
        private List<int> vulnerabilities = new List<int>();
        private List<int> passed = new List<int>();

        public ScannedReport()
        {
            InitializeComponent();
            selectedFileName = Scan.selectedFileName;
            //Form settings
            Text = "Scan for Vulnerabilities";
            ControlBox = false;
            DoubleBuffered = true;
            MaximizedBounds = Screen.FromHandle(Handle).WorkingArea;
            getAuditData();
            parseData();
            scanRegistry(reg_key, reg_item, value_data);
            ShowResults();
        }

        private void parseData()
        {

            var reg = new Regex("\"(.*?)\"");

            for (int i = 0; i < lines.Length; i++)
            {

                if (lines[i].Contains("value_data"))
                {


                    /*
                    var matches = reg.Matches(lines[i]);

                    foreach (var item in matches)
                    {

                        value_data[index] = item.ToString().Replace("\"", "");

                    }
                    */
                    var matches = reg.Matches(lines[i]);
                    Regex numbers = new Regex(@"\d+");
                    Match input_string = numbers.Match(lines[i]);

                    if (input_string.Success)
                    {
                        value_data[index] = input_string.Value;
                    }
                    else
                    {
                        value_data[index] = matches[0].ToString().Replace("\"", "");
                    }



                }

                if (lines[i].Contains("reg_key"))
                {
                    var matches = reg.Matches(lines[i]);
                    foreach (var item in matches)
                    {

                        reg_key[index] = item.ToString().Replace("\"", "");
                        if (item.ToString().Contains("HKLM")) { reg_key[index] = item.ToString().Replace("HKLM", "HKEY_LOCAL_MACHINE"); }
                        if (item.ToString().Contains("HKU")) { reg_key[index] = item.ToString().Replace("HKU", "HKEY_USERS"); }

                    }
                }


                if (lines[i].Contains("reg_item"))
                {
                    var matches = reg.Matches(lines[i]);
                    foreach (var item in matches)
                    {
                        reg_item[index] = item.ToString().Replace("\"", "");
                    }

                    index++;
                }

                if (lines[i].Contains("description"))
                {
                    var matches = reg.Matches(lines[i]);
                    foreach (var item in matches)
                    {
                        description[index] = item.ToString().Replace("\"", "");
                    }


                }

            }

        }

        private void scanRegistry(string[] reg_key, string[] reg_item, string[] value_data)
        {
            for (int i = 0; i < index; i++)
            {
                reg_key[i] = reg_key[i].Replace("\"", string.Empty);
                object value = Registry.GetValue(reg_key[i], reg_item[i], null);

                if (value != null)
                {

                    if (value.ToString() != value_data[i])
                    {
                        vulnerabilities.Add(i);
                    }

                    else
                    {
                        passed.Add(i);
                    }

                }

                else
                {
                    vulnerabilities.Add(i); //uncomment if add even values non existing
                }

            }
        }

        private void ShowResults()
        {
            for (int i = 0; i < vulnerabilities.Count; i++)
            {

                scanReport.Items.Add(description[vulnerabilities[i]] + "   " + value_data[vulnerabilities[i]], false);
                scanReport.Height = 419;
            }

            for (int i = 0; i < passed.Count; i++)
            {
                passedReportList.Items.Add(description[passed[i]] + "   " + value_data[passed[i]], false);
                passedReportList.Height = 419;
            }

        }

        private void ApplySelected_Click(object sender, EventArgs e)
        {
            int[] selectedVulnerabilities = scanReport.CheckedIndices.Cast<int>().ToArray();
            for (int i = 0; i < selectedVulnerabilities.Count(); i++)
            {
                try
                {
                    Registry.SetValue(reg_key[vulnerabilities[selectedVulnerabilities[i]]], reg_item[vulnerabilities[selectedVulnerabilities[i]]], value_data[vulnerabilities[selectedVulnerabilities[i]]]);
                }
                catch
                {
                    MessageBox.Show("Windows version not compatible with data about: " + description[vulnerabilities[i]]);
                    scanReport.Items.RemoveAt(selectedVulnerabilities[i]);
                    continue;
                }
                //scanReport.Items.RemoveAt(selectedVulnerabilities[i]); //Possibly redunant since I go back anyway
            }

            OpenChildForm(new SuccessDialog());

        }

        private void ApplyAll_Click(object sender, EventArgs e)
        {
            for (int i = 0; i < vulnerabilities.Count; i++)
            {

                try
                {
                    Registry.SetValue(reg_key[vulnerabilities[i]], reg_item[vulnerabilities[i]], value_data[vulnerabilities[i]]);
                }

                catch
                {
                    MessageBox.Show("Windows version not compatible with data about: " + description[vulnerabilities[i]]);
                    scanReport.Items.RemoveAt(vulnerabilities[i]);
                    continue;
                }

            }

            OpenChildForm(new SuccessDialog());


        }

        private void OpenChildForm(Form childForm)
        {
            currentChildForm = childForm;
            childForm.TopLevel = false;
            childForm.FormBorderStyle = FormBorderStyle.None;
            childForm.Dock = DockStyle.Fill;
            Controls.Add(childForm);
            childForm.Tag = childForm;
            childForm.BringToFront();
            childForm.Show();
        }

        private void getAuditData()
        {
            lines = System.IO.File.ReadAllLines(@selectedFileName);
        }

        private void showFailed_Click(object sender, EventArgs e)
        {
            passedReportList.Hide();
            scanReport.Show();
            showFailed.Hide();
            showPassed.Show();
        }

        private void backToScan_Click(object sender, EventArgs e)
        {
            resetData();
            Close();
        }

        private void resetData()
        {
            index = 0;
            selectedFileName = null;
            Array.Clear(lines, 0, lines.Length);
            Array.Clear(reg_key, 0, reg_key.Length);
            Array.Clear(reg_item, 0, reg_key.Length);
            Array.Clear(value_data, 0, reg_key.Length);
            Array.Clear(description, 0, reg_key.Length);
            vulnerabilities.Clear();
            passed.Clear();
            scanReport.Items.Clear();
        }

        private void showPassed_Click(object sender, EventArgs e)
        {
            passedReportList.Show();
            scanReport.Hide();
            showFailed.Show();
            showPassed.Hide();
        }

    }
}
